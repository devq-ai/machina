#!/usr/bin/env python3
"""
FastAPI MCP Server
FastAPI web framework integration using FastMCP framework.
"""

import asyncio
import json
import os
import subprocess
import tempfile
from typing import Dict, Any, List, Optional, Union
from datetime import datetime
import sys
from pathlib import Path

# Add parent directory to path for FastMCP imports
sys.path.insert(0, str(Path(__file__).parent.parent))

from fastmcp import FastMCP
import logfire

try:
    from pydantic import BaseModel, Field
    import aiofiles
    FASTAPI_DEPS_AVAILABLE = True
except ImportError:
    FASTAPI_DEPS_AVAILABLE = False
    BaseModel = object
    def Field(*args, **kwargs):
        return None
    aiofiles = None


class FastAPIProject(BaseModel if FASTAPI_DEPS_AVAILABLE else object):
    """FastAPI project model"""
    name: str = Field(..., description="Project name")
    path: str = Field(..., description="Project path")
    description: Optional[str] = Field(None, description="Project description")
    python_version: str = Field("3.11", description="Python version")
    created_at: str = Field(..., description="Creation timestamp")
    features: List[str] = Field(default_factory=list, description="Enabled features")


class FastAPIMCP:
    """
    FastAPI MCP Server using FastMCP framework

    Provides comprehensive FastAPI development operations including:
    - Project scaffolding and generation
    - API endpoint creation
    - Database model generation
    - Authentication setup
    - Testing framework integration
    - Docker containerization
    - API documentation
    """

    def __init__(self):
        self.mcp = FastMCP("fastapi-mcp", version="1.0.0", description="FastAPI web framework integration")
        self.projects_dir = os.getenv("FASTAPI_PROJECTS_DIR", "./fastapi_projects")
        self.default_python = os.getenv("FASTAPI_PYTHON", "python3")
        self.projects: Dict[str, FastAPIProject] = {}
        self._setup_tools()
        self._initialize()

    def _initialize(self):
        """Initialize FastAPI MCP"""
        try:
            # Create projects directory
            os.makedirs(self.projects_dir, exist_ok=True)
            logfire.info("FastAPI MCP initialized successfully")
        except Exception as e:
            logfire.error(f"Failed to initialize FastAPI MCP: {str(e)}")

    def _get_project_template(self, project_name: str, features: List[str]) -> Dict[str, str]:
        """Get FastAPI project template files"""
        files = {}

        # Main application file
        main_py = f'''"""
{project_name} - FastAPI Application
Generated by FastAPI MCP Server
"""

import os
from fastapi import FastAPI, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager
import logfire

# Configure Logfire
logfire.configure()

@asynccontextmanager
async def lifespan(app: FastAPI):
    logfire.info("Application starting up")
    yield
    logfire.info("Application shutting down")

app = FastAPI(
    title="{project_name}",
    description="FastAPI application generated by FastAPI MCP",
    version="1.0.0",
    lifespan=lifespan
)

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Enable Logfire instrumentation
logfire.instrument_fastapi(app, capture_headers=True)

@app.get("/")
async def root():
    """Root endpoint"""
    return {{"message": "Welcome to {project_name}", "status": "healthy"}}

@app.get("/health")
async def health_check():
    """Health check endpoint"""
    with logfire.span("Health check"):
        return {{"status": "healthy", "service": "{project_name}"}}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        reload=True
    )
'''

        files["main.py"] = main_py

        # Requirements file
        requirements = '''fastapi>=0.104.0
uvicorn[standard]>=0.24.0
pydantic>=2.5.0
logfire[fastapi]>=0.28.0
python-dotenv>=1.0.0
'''

        if "database" in features:
            requirements += '''sqlalchemy>=2.0.0
alembic>=1.12.0
'''

        if "auth" in features:
            requirements += '''python-jose[cryptography]>=3.3.0
passlib[bcrypt]>=1.7.4
python-multipart>=0.0.6
'''

        if "testing" in features:
            requirements += '''pytest>=7.4.0
pytest-asyncio>=0.21.0
httpx>=0.25.0
'''

        files["requirements.txt"] = requirements

        # Environment file
        env_file = f'''# {project_name} Environment Variables
DEBUG=true
SECRET_KEY=your-secret-key-here

# Database
DATABASE_URL=sqlite:///./app.db

# Logfire
LOGFIRE_TOKEN=your-logfire-token
LOGFIRE_PROJECT_NAME={project_name.lower().replace(" ", "-")}

# API Configuration
API_V1_STR=/api/v1
'''

        files[".env.example"] = env_file

        # Dockerfile
        dockerfile = f'''FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 8000

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
'''

        files["Dockerfile"] = dockerfile

        # Docker Compose
        docker_compose = f'''version: '3.8'

services:
  {project_name.lower().replace(" ", "-")}:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DEBUG=true
    volumes:
      - .:/app
    command: uvicorn main:app --host 0.0.0.0 --port 8000 --reload
'''

        files["docker-compose.yml"] = docker_compose

        # Add database files if requested
        if "database" in features:
            files["database.py"] = self._get_database_template()
            files["models/__init__.py"] = ""
            files["models/base.py"] = self._get_base_model_template()

        # Add auth files if requested
        if "auth" in features:
            files["auth.py"] = self._get_auth_template()
            files["schemas/__init__.py"] = ""
            files["schemas/user.py"] = self._get_user_schema_template()

        # Add testing files if requested
        if "testing" in features:
            files["tests/__init__.py"] = ""
            files["tests/test_main.py"] = self._get_test_template(project_name)
            files["conftest.py"] = self._get_conftest_template()

        # README
        readme = f'''# {project_name}

FastAPI application generated by FastAPI MCP Server.

## Features

{chr(10).join(f"- {feature.title()}" for feature in features)}

## Setup

1. Install dependencies:
   ```bash
   pip install -r requirements.txt
   ```

2. Copy environment file:
   ```bash
   cp .env.example .env
   ```

3. Run the application:
   ```bash
   python main.py
   ```

## API Documentation

- Swagger UI: http://localhost:8000/docs
- ReDoc: http://localhost:8000/redoc

## Docker

```bash
docker-compose up --build
```

## Testing

```bash
pytest
```
'''

        files["README.md"] = readme

        return files

    def _get_database_template(self) -> str:
        """Get database configuration template"""
        return '''"""
Database configuration
"""

from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
import os
from dotenv import load_dotenv

load_dotenv()

SQLALCHEMY_DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///./app.db")

engine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

def get_db():
    """Database dependency"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
'''

    def _get_base_model_template(self) -> str:
        """Get base model template"""
        return '''"""
Base database models
"""

from sqlalchemy import Column, Integer, String, DateTime, Boolean
from sqlalchemy.ext.declarative import declarative_base
from datetime import datetime

Base = declarative_base()

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True)
    hashed_password = Column(String)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
'''

    def _get_auth_template(self) -> str:
        """Get authentication template"""
        return '''"""
Authentication utilities
"""

from datetime import datetime, timedelta
from jose import JWTError, jwt
from passlib.context import CryptContext
from fastapi import HTTPException, status
import os

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
SECRET_KEY = os.getenv("SECRET_KEY", "your-secret-key")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: timedelta = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt
'''

    def _get_user_schema_template(self) -> str:
        """Get user schema template"""
        return '''"""
User schemas
"""

from pydantic import BaseModel, EmailStr
from typing import Optional
from datetime import datetime

class UserBase(BaseModel):
    email: EmailStr

class UserCreate(UserBase):
    password: str

class UserResponse(UserBase):
    id: int
    is_active: bool
    created_at: datetime

    class Config:
        from_attributes = True
'''

    def _get_test_template(self, project_name: str) -> str:
        """Get test template"""
        return f'''"""
Test suite for {project_name}
"""

import pytest
from fastapi.testclient import TestClient
from main import app

client = TestClient(app)

def test_root():
    response = client.get("/")
    assert response.status_code == 200
    data = response.json()
    assert "message" in data
    assert data["status"] == "healthy"

def test_health_check():
    response = client.get("/health")
    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "healthy"
    assert data["service"] == "{project_name}"
'''

    def _get_conftest_template(self) -> str:
        """Get pytest configuration template"""
        return '''"""
Pytest configuration
"""

import pytest
import asyncio
from fastapi.testclient import TestClient

@pytest.fixture(scope="session")
def event_loop():
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()

@pytest.fixture
def client():
    from main import app
    with TestClient(app) as test_client:
        yield test_client
'''

    def _setup_tools(self):
        """Setup FastAPI MCP tools"""

        @self.mcp.tool(
            name="create_project",
            description="Create a new FastAPI project",
            input_schema={
                "type": "object",
                "properties": {
                    "name": {"type": "string", "description": "Project name"},
                    "description": {"type": "string", "description": "Project description"},
                    "features": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Features to include (database, auth, testing, docker)"
                    },
                    "python_version": {"type": "string", "description": "Python version", "default": "3.11"}
                },
                "required": ["name"]
            }
        )
        async def create_project(name: str, description: str = None, features: List[str] = None,
                               python_version: str = "3.11") -> Dict[str, Any]:
            """Create a new FastAPI project"""
            try:
                if not FASTAPI_DEPS_AVAILABLE:
                    return {"error": "FastAPI dependencies not available"}

                features = features or []
                safe_name = name.lower().replace(" ", "_").replace("-", "_")
                project_path = os.path.join(self.projects_dir, safe_name)

                if os.path.exists(project_path):
                    return {"error": f"Project '{safe_name}' already exists"}

                # Create project directory
                os.makedirs(project_path, exist_ok=True)

                # Generate project files
                template_files = self._get_project_template(name, features)

                # Write files
                for file_path, content in template_files.items():
                    full_path = os.path.join(project_path, file_path)

                    # Create subdirectories if needed
                    os.makedirs(os.path.dirname(full_path), exist_ok=True)

                    if aiofiles:
                        async with aiofiles.open(full_path, 'w') as f:
                            await f.write(content)
                    else:
                        with open(full_path, 'w') as f:
                            f.write(content)

                # Create project record
                project = {
                    "name": name,
                    "path": project_path,
                    "description": description,
                    "python_version": python_version,
                    "created_at": datetime.utcnow().isoformat(),
                    "features": features
                }

                if FASTAPI_DEPS_AVAILABLE:
                    self.projects[safe_name] = FastAPIProject(**project)
                else:
                    self.projects[safe_name] = project

                return {
                    "status": "created",
                    "project_name": name,
                    "safe_name": safe_name,
                    "path": project_path,
                    "features": features,
                    "files_created": len(template_files)
                }

            except Exception as e:
                logfire.error(f"Failed to create project: {str(e)}")
                return {"error": f"Project creation failed: {str(e)}"}

        @self.mcp.tool(
            name="add_endpoint",
            description="Add a new API endpoint to existing project",
            input_schema={
                "type": "object",
                "properties": {
                    "project_name": {"type": "string", "description": "Project name"},
                    "endpoint_path": {"type": "string", "description": "Endpoint path (e.g., /users)"},
                    "method": {"type": "string", "description": "HTTP method", "enum": ["GET", "POST", "PUT", "DELETE"]},
                    "description": {"type": "string", "description": "Endpoint description"},
                    "response_model": {"type": "string", "description": "Response model name (optional)"}
                },
                "required": ["project_name", "endpoint_path", "method"]
            }
        )
        async def add_endpoint(project_name: str, endpoint_path: str, method: str,
                             description: str = None, response_model: str = None) -> Dict[str, Any]:
            """Add a new API endpoint to existing project"""
            try:
                safe_name = project_name.lower().replace(" ", "_").replace("-", "_")

                if safe_name not in self.projects:
                    return {"error": f"Project '{project_name}' not found"}

                project_path = os.path.join(self.projects_dir, safe_name)
                main_file = os.path.join(project_path, "main.py")

                if not os.path.exists(main_file):
                    return {"error": f"Main file not found in project '{project_name}'"}

                # Generate endpoint code
                endpoint_code = f'''
@app.{method.lower()}("{endpoint_path}")
async def {endpoint_path.replace("/", "").replace("-", "_")}():
    """{description or f"{method} {endpoint_path}"}"""
    with logfire.span("{method} {endpoint_path}"):
        # TODO: Implement endpoint logic
        return {{"message": "Endpoint {endpoint_path} works", "method": "{method}"}}
'''

                # Read existing file
                if aiofiles:
                    async with aiofiles.open(main_file, 'r') as f:
                        content = await f.read()
                else:
                    with open(main_file, 'r') as f:
                        content = f.read()

                # Add endpoint before the main block
                main_block_index = content.find('if __name__ == "__main__"')
                if main_block_index != -1:
                    new_content = content[:main_block_index] + endpoint_code + "\n" + content[main_block_index:]
                else:
                    new_content = content + endpoint_code

                # Write updated file
                if aiofiles:
                    async with aiofiles.open(main_file, 'w') as f:
                        await f.write(new_content)
                else:
                    with open(main_file, 'w') as f:
                        f.write(new_content)

                return {
                    "status": "added",
                    "project_name": project_name,
                    "endpoint_path": endpoint_path,
                    "method": method,
                    "description": description
                }

            except Exception as e:
                logfire.error(f"Failed to add endpoint: {str(e)}")
                return {"error": f"Endpoint addition failed: {str(e)}"}

        @self.mcp.tool(
            name="list_projects",
            description="List all FastAPI projects",
            input_schema={
                "type": "object",
                "properties": {}
            }
        )
        async def list_projects() -> Dict[str, Any]:
            """List all FastAPI projects"""
            try:
                projects_list = []

                for project_name, project in self.projects.items():
                    if FASTAPI_DEPS_AVAILABLE and hasattr(project, 'name'):
                        project_data = {
                            "name": project.name,
                            "safe_name": project_name,
                            "path": project.path,
                            "description": project.description,
                            "features": project.features,
                            "created_at": project.created_at,
                            "python_version": project.python_version
                        }
                    else:
                        project_data = {
                            "name": project.get('name'),
                            "safe_name": project_name,
                            "path": project.get('path'),
                            "description": project.get('description'),
                            "features": project.get('features', []),
                            "created_at": project.get('created_at'),
                            "python_version": project.get('python_version', '3.11')
                        }

                    projects_list.append(project_data)

                return {
                    "total_projects": len(projects_list),
                    "projects": projects_list
                }

            except Exception as e:
                logfire.error(f"Failed to list projects: {str(e)}")
                return {"error": f"Project listing failed: {str(e)}"}

        @self.mcp.tool(
            name="run_project",
            description="Run a FastAPI project",
            input_schema={
                "type": "object",
                "properties": {
                    "project_name": {"type": "string", "description": "Project name"},
                    "host": {"type": "string", "description": "Host to bind to", "default": "127.0.0.1"},
                    "port": {"type": "integer", "description": "Port to bind to", "default": 8000},
                    "reload": {"type": "boolean", "description": "Enable auto-reload", "default": True}
                },
                "required": ["project_name"]
            }
        )
        async def run_project(project_name: str, host: str = "127.0.0.1", port: int = 8000,
                            reload: bool = True) -> Dict[str, Any]:
            """Run a FastAPI project"""
            try:
                safe_name = project_name.lower().replace(" ", "_").replace("-", "_")

                if safe_name not in self.projects:
                    return {"error": f"Project '{project_name}' not found"}

                project_path = os.path.join(self.projects_dir, safe_name)
                main_file = os.path.join(project_path, "main.py")

                if not os.path.exists(main_file):
                    return {"error": f"Main file not found in project '{project_name}'"}

                # Run the project using uvicorn
                cmd = [
                    self.default_python, "-m", "uvicorn", "main:app",
                    "--host", host,
                    "--port", str(port)
                ]

                if reload:
                    cmd.append("--reload")

                # Start the process (note: this will be non-blocking in practice)
                process = subprocess.Popen(
                    cmd,
                    cwd=project_path,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE
                )

                return {
                    "status": "started",
                    "project_name": project_name,
                    "host": host,
                    "port": port,
                    "reload": reload,
                    "url": f"http://{host}:{port}",
                    "docs_url": f"http://{host}:{port}/docs",
                    "process_id": process.pid
                }

            except Exception as e:
                logfire.error(f"Failed to run project: {str(e)}")
                return {"error": f"Project execution failed: {str(e)}"}

        @self.mcp.tool(
            name="install_dependencies",
            description="Install project dependencies",
            input_schema={
                "type": "object",
                "properties": {
                    "project_name": {"type": "string", "description": "Project name"}
                },
                "required": ["project_name"]
            }
        )
        async def install_dependencies(project_name: str) -> Dict[str, Any]:
            """Install project dependencies"""
            try:
                safe_name = project_name.lower().replace(" ", "_").replace("-", "_")

                if safe_name not in self.projects:
                    return {"error": f"Project '{project_name}' not found"}

                project_path = os.path.join(self.projects_dir, safe_name)
                requirements_file = os.path.join(project_path, "requirements.txt")

                if not os.path.exists(requirements_file):
                    return {"error": f"Requirements file not found in project '{project_name}'"}

                # Install dependencies
                result = subprocess.run(
                    [self.default_python, "-m", "pip", "install", "-r", "requirements.txt"],
                    cwd=project_path,
                    capture_output=True,
                    text=True
                )

                if result.returncode == 0:
                    return {
                        "status": "installed",
                        "project_name": project_name,
                        "output": result.stdout
                    }
                else:
                    return {
                        "status": "failed",
                        "project_name": project_name,
                        "error": result.stderr
                    }

            except Exception as e:
                logfire.error(f"Failed to install dependencies: {str(e)}")
                return {"error": f"Dependency installation failed: {str(e)}"}

        @self.mcp.tool(
            name="generate_openapi_spec",
            description="Generate OpenAPI specification for project",
            input_schema={
                "type": "object",
                "properties": {
                    "project_name": {"type": "string", "description": "Project name"}
                },
                "required": ["project_name"]
            }
        )
        async def generate_openapi_spec(project_name: str) -> Dict[str, Any]:
            """Generate OpenAPI specification for project"""
            try:
                safe_name = project_name.lower().replace(" ", "_").replace("-", "_")

                if safe_name not in self.projects:
                    return {"error": f"Project '{project_name}' not found"}

                project_path = os.path.join(self.projects_dir, safe_name)

                # Generate OpenAPI spec using FastAPI
                script = '''
import sys
import json
sys.path.insert(0, ".")
from main import app
print(json.dumps(app.openapi(), indent=2))
'''

                with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
                    f.write(script)
                    script_path = f.name

                try:
                    result = subprocess.run(
                        [self.default_python, script_path],
                        cwd=project_path,
                        capture_output=True,
                        text=True
                    )

                    if result.returncode == 0:
                        openapi_spec = json.loads(result.stdout)

                        # Save to file
                        spec_file = os.path.join(project_path, "openapi.json")
                        with open(spec_file, 'w') as f:
                            json.dump(openapi_spec, f, indent=2)

                        return {
                            "status": "generated",
                            "project_name": project_name,
                            "spec_file": spec_file,
                            "openapi_version": openapi_spec.get("openapi"),
                            "info": openapi_spec.get("info", {}),
                            "paths_count": len(openapi_spec.get("paths", {}))
                        }
                    else:
                        return {
                            "status": "failed",
                            "project_name": project_name,
                            "error": result.stderr
                        }
                finally:
                    os.unlink(script_path)

            except Exception as e:
                logfire.error(f"Failed to generate OpenAPI spec: {str(e)}")
                return {"error": f"OpenAPI generation failed: {str(e)}"}

    async def run(self):
        """Run the FastAPI MCP server"""
        await self.mcp.run_stdio()


async def main():
    """Main entry point"""
    server = FastAPIMCP()
    await server.run()


if __name__ == "__main__":
    asyncio.run(main())
