#!/usr/bin/env python3
"""
FastMCP MCP Server - Production Implementation
FastMCP Framework Management and Project Generation
"""

import asyncio
import json
from pathlib import Path
from typing import Dict, Any, List, Optional
from datetime import datetime
import mcp.types as types
from mcp.server import Server, NotificationOptions
from mcp.server.models import InitializationOptions
import mcp.server.stdio


class FastMCPProject:
    """Represents a FastMCP project"""

    def __init__(self, name: str, path: Path, template: str = "basic"):
        self.name = name
        self.path = path
        self.template = template
        self.created_at = datetime.now().isoformat()
        self.tools = []
        self.config = {
            "name": name,
            "version": "1.0.0",
            "description": f"FastMCP server project: {name}",
            "template": template
        }


class FastMCPFramework:
    """FastMCP framework management"""

    def __init__(self):
        self.projects: Dict[str, FastMCPProject] = {}
        self.templates = {
            "basic": {
                "name": "basic",
                "description": "Basic MCP server with essential tools",
                "structure": {
                    "src/server.py": self._get_basic_server_template(),
                    "src/tools.py": self._get_basic_tools_template(),
                    "requirements.txt": self._get_basic_requirements(),
                    "README.md": self._get_basic_readme_template(),
                    ".env.example": self._get_basic_env_template()
                }
            },
            "advanced": {
                "name": "advanced",
                "description": "Advanced server with auth and database",
                "structure": {
                    "src/server.py": self._get_advanced_server_template(),
                    "src/tools.py": self._get_basic_tools_template(),
                    "src/auth.py": self._get_auth_template(),
                    "src/database.py": self._get_database_template(),
                    "requirements.txt": self._get_advanced_requirements(),
                    "README.md": self._get_advanced_readme_template(),
                    ".env.example": self._get_advanced_env_template()
                }
            },
            "enterprise": {
                "name": "enterprise",
                "description": "Enterprise-grade with monitoring and scalability",
                "structure": {
                    "src/server.py": self._get_enterprise_server_template(),
                    "src/tools.py": self._get_basic_tools_template(),
                    "src/auth.py": self._get_auth_template(),
                    "src/database.py": self._get_database_template(),
                    "src/monitoring.py": self._get_monitoring_template(),
                    "src/cache.py": self._get_cache_template(),
                    "requirements.txt": self._get_enterprise_requirements(),
                    "docker-compose.yml": self._get_docker_compose_template(),
                    "Dockerfile": self._get_dockerfile_template(),
                    "README.md": self._get_enterprise_readme_template(),
                    ".env.example": self._get_enterprise_env_template()
                }
            },
            "ai-agent": {
                "name": "ai-agent",
                "description": "AI agent integration template with LLM support",
                "structure": {
                    "src/server.py": self._get_ai_server_template(),
                    "src/tools.py": self._get_ai_tools_template(),
                    "src/agents.py": self._get_agents_template(),
                    "src/prompts.py": self._get_prompts_template(),
                    "requirements.txt": self._get_ai_requirements(),
                    "README.md": self._get_ai_readme_template(),
                    ".env.example": self._get_ai_env_template()
                }
            }
        }

    def _get_basic_server_template(self) -> str:
        return '''#!/usr/bin/env python3
"""
{project_name} MCP Server
Generated by FastMCP Framework
"""

import asyncio
import json
from typing import Dict, Any, List, Optional
import mcp.types as types
from mcp.server import Server, NotificationOptions
from mcp.server.models import InitializationOptions
import mcp.server.stdio
from tools import get_tools, handle_tool_call


class {class_name}MCPServer:
    """Main MCP server implementation"""

    def __init__(self):
        self.server = Server("{project_name}")

        @self.server.list_tools()
        async def handle_list_tools() -> List[types.Tool]:
            return get_tools()

        @self.server.call_tool()
        async def handle_call_tool(name: str, arguments: Optional[Dict[str, Any]] = None) -> List[types.TextContent]:
            result = await handle_tool_call(name, arguments or {})
            return [types.TextContent(type="text", text=json.dumps(result, indent=2))]

    async def run(self):
        """Run the MCP server"""
        async with mcp.server.stdio.stdio_server() as (read_stream, write_stream):
            await self.server.run(
                read_stream,
                write_stream,
                InitializationOptions(
                    server_name="{project_name}",
                    server_version="1.0.0",
                    capabilities=self.server.get_capabilities(
                        notification_options=NotificationOptions(),
                        experimental_capabilities={},
                    ),
                ),
            )


async def main():
    server = {class_name}MCPServer()
    await server.run()


if __name__ == "__main__":
    asyncio.run(main())
'''

    def _get_basic_tools_template(self) -> str:
        return '''"""
MCP Tools Implementation
"""

from typing import Dict, Any, List
import mcp.types as types


def get_tools() -> List[types.Tool]:
    """Define available tools"""
    return [
        types.Tool(
            name="example_tool",
            description="An example tool that echoes input",
            inputSchema={
                "type": "object",
                "properties": {
                    "message": {
                        "type": "string",
                        "description": "Message to echo"
                    }
                },
                "required": ["message"]
            }
        ),
        types.Tool(
            name="health_check",
            description="Check server health",
            inputSchema={
                "type": "object",
                "properties": {}
            }
        )
    ]


async def handle_tool_call(name: str, arguments: Dict[str, Any]) -> Dict[str, Any]:
    """Handle tool execution"""
    if name == "example_tool":
        return {
            "status": "success",
            "message": arguments.get("message", ""),
            "timestamp": str(datetime.now())
        }
    elif name == "health_check":
        return {
            "status": "healthy",
            "service": "{project_name}",
            "timestamp": str(datetime.now())
        }
    else:
        return {"error": f"Unknown tool: {name}"}
'''

    def _get_basic_requirements(self) -> str:
        return """mcp>=1.0.0
fastmcp>=0.1.0
python-dotenv>=1.0.0
"""

    def _get_basic_readme_template(self) -> str:
        return """# {project_name}

A FastMCP server project generated by the FastMCP framework.

## Installation

```bash
pip install -r requirements.txt
```

## Configuration

Copy `.env.example` to `.env` and configure your settings.

## Running the Server

```bash
python src/server.py
```

## Available Tools

- `example_tool`: An example tool that echoes input
- `health_check`: Check server health status

## Development

Add new tools in `src/tools.py` and update the `get_tools()` and `handle_tool_call()` functions.
"""

    def _get_basic_env_template(self) -> str:
        return """# FastMCP Server Configuration
DEBUG=true
LOG_LEVEL=info
"""

    def _get_advanced_server_template(self) -> str:
        return self._get_basic_server_template().replace(
            "from tools import",
            "from tools import\nfrom auth import authenticate\nfrom database import get_db_session"
        )

    def _get_auth_template(self) -> str:
        return '''"""
Authentication module
"""

from typing import Optional
import os
import jwt
from datetime import datetime, timedelta


SECRET_KEY = os.getenv("SECRET_KEY", "your-secret-key")


def generate_token(user_id: str) -> str:
    """Generate JWT token"""
    payload = {
        "user_id": user_id,
        "exp": datetime.utcnow() + timedelta(hours=24)
    }
    return jwt.encode(payload, SECRET_KEY, algorithm="HS256")


def verify_token(token: str) -> Optional[str]:
    """Verify JWT token and return user_id"""
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
        return payload.get("user_id")
    except jwt.InvalidTokenError:
        return None


async def authenticate(token: Optional[str]) -> bool:
    """Authenticate request"""
    if not token:
        return False
    return verify_token(token) is not None
'''

    def _get_database_template(self) -> str:
        return '''"""
Database module
"""

import os
from contextlib import asynccontextmanager
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import declarative_base, sessionmaker


DATABASE_URL = os.getenv("DATABASE_URL", "sqlite+aiosqlite:///./data.db")

engine = create_async_engine(DATABASE_URL, echo=False)
AsyncSessionLocal = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)
Base = declarative_base()


@asynccontextmanager
async def get_db_session():
    """Get database session"""
    async with AsyncSessionLocal() as session:
        try:
            yield session
            await session.commit()
        except Exception:
            await session.rollback()
            raise
        finally:
            await session.close()
'''

    def _get_advanced_requirements(self) -> str:
        return self._get_basic_requirements() + """pyjwt>=2.8.0
sqlalchemy>=2.0.0
aiosqlite>=0.19.0
"""

    def _get_advanced_readme_template(self) -> str:
        return self._get_basic_readme_template().replace(
            "## Available Tools",
            "## Features\n\n- JWT Authentication\n- Database integration with SQLAlchemy\n- Async operations\n\n## Available Tools"
        )

    def _get_advanced_env_template(self) -> str:
        return self._get_basic_env_template() + """
# Authentication
SECRET_KEY=your-secret-key-here

# Database
DATABASE_URL=sqlite+aiosqlite:///./data.db
"""

    def _get_enterprise_server_template(self) -> str:
        return self._get_advanced_server_template().replace(
            "from database import",
            "from database import\nfrom monitoring import setup_monitoring\nfrom cache import cache_manager"
        )

    def _get_monitoring_template(self) -> str:
        return '''"""
Monitoring and observability
"""

import os
import time
from functools import wraps
from typing import Any, Callable
import logfire


logfire.configure(token=os.getenv("LOGFIRE_TOKEN"))


def monitor_performance(func: Callable) -> Callable:
    """Monitor function performance"""
    @wraps(func)
    async def wrapper(*args, **kwargs) -> Any:
        start_time = time.time()
        with logfire.span(f"Function: {func.__name__}"):
            try:
                result = await func(*args, **kwargs)
                execution_time = time.time() - start_time
                logfire.info(f"{func.__name__} completed", duration=execution_time)
                return result
            except Exception as e:
                logfire.error(f"{func.__name__} failed", error=str(e))
                raise
    return wrapper


def setup_monitoring():
    """Initialize monitoring"""
    logfire.info("Monitoring initialized")
'''

    def _get_cache_template(self) -> str:
        return '''"""
Cache management
"""

import os
import json
from typing import Any, Optional
import redis.asyncio as redis


REDIS_URL = os.getenv("REDIS_URL", "redis://localhost:6379")


class CacheManager:
    """Redis cache manager"""

    def __init__(self):
        self.redis = None

    async def connect(self):
        """Connect to Redis"""
        self.redis = await redis.from_url(REDIS_URL)

    async def get(self, key: str) -> Optional[Any]:
        """Get value from cache"""
        if not self.redis:
            return None
        value = await self.redis.get(key)
        return json.loads(value) if value else None

    async def set(self, key: str, value: Any, ttl: int = 3600):
        """Set value in cache"""
        if self.redis:
            await self.redis.set(key, json.dumps(value), ex=ttl)

    async def close(self):
        """Close Redis connection"""
        if self.redis:
            await self.redis.close()


cache_manager = CacheManager()
'''

    def _get_enterprise_requirements(self) -> str:
        return self._get_advanced_requirements() + """redis>=5.0.0
logfire>=0.28.0
prometheus-client>=0.19.0
"""

    def _get_docker_compose_template(self) -> str:
        return """version: '3.8'

services:
  fastmcp-server:
    build: .
    ports:
      - "8080:8080"
    environment:
      - DATABASE_URL=postgresql://postgres:password@db:5432/fastmcp
      - REDIS_URL=redis://redis:6379
    depends_on:
      - db
      - redis

  db:
    image: postgres:15
    environment:
      - POSTGRES_DB=fastmcp
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

volumes:
  postgres_data:
"""

    def _get_dockerfile_template(self) -> str:
        return """FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY src/ ./src/

CMD ["python", "src/server.py"]
"""

    def _get_enterprise_readme_template(self) -> str:
        return """# {project_name}

Enterprise-grade FastMCP server with monitoring, caching, and scalability.

## Features

- JWT Authentication
- PostgreSQL database with async SQLAlchemy
- Redis caching
- Logfire monitoring and observability
- Docker deployment ready
- Horizontal scaling support

## Deployment

### Docker Compose

```bash
docker-compose up -d
```

### Kubernetes

See `k8s/` directory for Kubernetes manifests.

## Monitoring

Access Logfire dashboard for real-time monitoring and performance metrics.

## Available Tools

- `example_tool`: An example tool that echoes input
- `health_check`: Check server health status

## Development

Add new tools in `src/tools.py` and update the `get_tools()` and `handle_tool_call()` functions.
"""

    def _get_enterprise_env_template(self) -> str:
        return self._get_advanced_env_template() + """
# Redis
REDIS_URL=redis://localhost:6379

# Monitoring
LOGFIRE_TOKEN=your-logfire-token
"""

    def _get_ai_server_template(self) -> str:
        return self._get_basic_server_template().replace(
            "from tools import",
            "from tools import\nfrom agents import AgentManager"
        )

    def _get_ai_tools_template(self) -> str:
        return '''"""
AI-powered tools implementation
"""

from typing import Dict, Any, List
import mcp.types as types
from agents import agent_manager


def get_tools() -> List[types.Tool]:
    """Define AI-powered tools"""
    return [
        types.Tool(
            name="ai_complete",
            description="Complete text using AI",
            inputSchema={
                "type": "object",
                "properties": {
                    "prompt": {
                        "type": "string",
                        "description": "Text prompt for completion"
                    },
                    "max_tokens": {
                        "type": "integer",
                        "description": "Maximum tokens to generate",
                        "default": 100
                    }
                },
                "required": ["prompt"]
            }
        ),
        types.Tool(
            name="ai_analyze",
            description="Analyze text or data using AI",
            inputSchema={
                "type": "object",
                "properties": {
                    "input": {
                        "type": "string",
                        "description": "Text or data to analyze"
                    },
                    "analysis_type": {
                        "type": "string",
                        "enum": ["sentiment", "summary", "entities", "classification"],
                        "description": "Type of analysis to perform"
                    }
                },
                "required": ["input", "analysis_type"]
            }
        ),
        types.Tool(
            name="health_check",
            description="Check server and AI model health",
            inputSchema={
                "type": "object",
                "properties": {}
            }
        )
    ]


async def handle_tool_call(name: str, arguments: Dict[str, Any]) -> Dict[str, Any]:
    """Handle AI tool execution"""
    if name == "ai_complete":
        response = await agent_manager.complete(
            prompt=arguments["prompt"],
            max_tokens=arguments.get("max_tokens", 100)
        )
        return {
            "status": "success",
            "completion": response,
            "model": agent_manager.model_name
        }

    elif name == "ai_analyze":
        result = await agent_manager.analyze(
            input_text=arguments["input"],
            analysis_type=arguments["analysis_type"]
        )
        return {
            "status": "success",
            "analysis": result,
            "type": arguments["analysis_type"]
        }

    elif name == "health_check":
        health = await agent_manager.health_check()
        return {
            "status": "healthy" if health["connected"] else "unhealthy",
            "service": "{project_name}",
            "ai_model": health["model"],
            "model_status": health["status"]
        }

    else:
        return {"error": f"Unknown tool: {name}"}
'''

    def _get_agents_template(self) -> str:
        return '''"""
AI Agent management
"""

import os
from typing import Dict, Any, Optional
import openai
from anthropic import Anthropic


class AgentManager:
    """Manage AI agents and models"""

    def __init__(self):
        self.provider = os.getenv("AI_PROVIDER", "openai")
        self.model_name = os.getenv("AI_MODEL", "gpt-4")

        if self.provider == "openai":
            openai.api_key = os.getenv("OPENAI_API_KEY")
            self.client = openai
        elif self.provider == "anthropic":
            self.client = Anthropic(api_key=os.getenv("ANTHROPIC_API_KEY"))

    async def complete(self, prompt: str, max_tokens: int = 100) -> str:
        """Generate text completion"""
        if self.provider == "openai":
            response = await self.client.ChatCompletion.acreate(
                model=self.model_name,
                messages=[{"role": "user", "content": prompt}],
                max_tokens=max_tokens
            )
            return response.choices[0].message.content
        elif self.provider == "anthropic":
            response = await self.client.messages.create(
                model=self.model_name,
                messages=[{"role": "user", "content": prompt}],
                max_tokens=max_tokens
            )
            return response.content[0].text

    async def analyze(self, input_text: str, analysis_type: str) -> Dict[str, Any]:
        """Analyze text based on type"""
        prompts = {
            "sentiment": f"Analyze the sentiment of this text: {input_text}",
            "summary": f"Summarize this text: {input_text}",
            "entities": f"Extract named entities from this text: {input_text}",
            "classification": f"Classify this text by category: {input_text}"
        }

        prompt = prompts.get(analysis_type, f"Analyze this text: {input_text}")
        result = await self.complete(prompt, max_tokens=200)

        return {
            "result": result,
            "input_length": len(input_text),
            "analysis_type": analysis_type
        }

    async def health_check(self) -> Dict[str, Any]:
        """Check AI model health"""
        try:
            # Test with simple completion
            result = await self.complete("Hello", max_tokens=5)
            return {
                "connected": True,
                "model": self.model_name,
                "provider": self.provider,
                "status": "operational"
            }
        except Exception as e:
            return {
                "connected": False,
                "model": self.model_name,
                "provider": self.provider,
                "status": f"error: {str(e)}"
            }


agent_manager = AgentManager()
'''

    def _get_prompts_template(self) -> str:
        return '''"""
AI Prompt templates
"""

SYSTEM_PROMPTS = {
    "assistant": "You are a helpful AI assistant integrated into a FastMCP server.",
    "analyzer": "You are an expert data analyst. Provide clear and concise analysis.",
    "coder": "You are an expert programmer. Generate clean, well-documented code."
}

TASK_PROMPTS = {
    "sentiment": """
Analyze the sentiment of the following text.
Provide a score from -1 (very negative) to 1 (very positive) and explain your reasoning.
Text: {text}
""",

    "summary": """
Provide a concise summary of the following text.
Keep it under 100 words and capture the main points.
Text: {text}
""",

    "entities": """
Extract all named entities from the following text.
Categories: PERSON, ORGANIZATION, LOCATION, DATE, OTHER
Text: {text}
""",

    "classification": """
Classify the following text into one of these categories:
- Technology
- Business
- Science
- Health
- Entertainment
- Other
Text: {text}
"""
}
'''

    def _get_ai_requirements(self) -> str:
        return self._get_basic_requirements() + """openai>=1.0.0
anthropic>=0.18.0
tiktoken>=0.5.0
"""

    def _get_ai_readme_template(self) -> str:
        return """# {project_name}

AI-powered FastMCP server with LLM integration.

## Features

- Multiple AI provider support (OpenAI, Anthropic)
- Text completion and analysis
- Configurable prompts and agents
- Async AI operations

## Configuration

Set your AI provider and API keys in `.env`:

```
AI_PROVIDER=openai
AI_MODEL=gpt-4
OPENAI_API_KEY=your-key-here
```

## Available Tools

- `ai_complete`: Generate text completions
- `ai_analyze`: Analyze text (sentiment, summary, entities, classification)
- `health_check`: Check server and AI model health

## Development

Add new AI tools in `src/tools.py` and prompts in `src/prompts.py`.
"""

    def _get_ai_env_template(self) -> str:
        return self._get_basic_env_template() + """
# AI Configuration
AI_PROVIDER=openai
AI_MODEL=gpt-4
OPENAI_API_KEY=your-openai-key
ANTHROPIC_API_KEY=your-anthropic-key
"""

    def create_project(self, name: str, template: str = "basic", base_path: Optional[Path] = None) -> FastMCPProject:
        """Create a new FastMCP project"""
        if template not in self.templates:
            raise ValueError(f"Unknown template: {template}")

        # Determine project path
        if base_path is None:
            base_path = Path.cwd()

        project_path = base_path / name

        # Create project directory
        project_path.mkdir(parents=True, exist_ok=True)

        # Create project instance
        project = FastMCPProject(name, project_path, template)

        # Get template structure
        template_structure = self.templates[template]["structure"]

        # Create project files
        for file_path, content in template_structure.items():
            full_path = project_path / file_path
            full_path.parent.mkdir(parents=True, exist_ok=True)

            # Replace placeholders
            content = content.replace("{project_name}", name)
            content = content.replace("{class_name}", self._to_class_name(name))

            with open(full_path, 'w') as f:
                f.write(content)

        # Store project
        self.projects[name] = project

        return project

    def _to_class_name(self, name: str) -> str:
        """Convert project name to class name"""
        return ''.join(word.capitalize() for word in name.replace('-', '_').split('_'))

    def add_tool_to_project(self, project_name: str, tool_name: str, tool_description: str,
                          parameters: List[Dict[str, Any]]) -> bool:
        """Add a new tool to an existing project"""
        if project_name not in self.projects:
            raise ValueError(f"Project {project_name} not found")

        project = self.projects[project_name]
        tools_path = project.path / "src" / "tools.py"

        if not tools_path.exists():
            raise FileNotFoundError(f"Tools file not found: {tools_path}")

        # Generate tool definition
        tool_def = f'''
        types.Tool(
            name="{tool_name}",
            description="{tool_description}",
            inputSchema={{
                "type": "object",
                "properties": {{
                    {self._generate_properties(parameters)}
                }},
                "required": {json.dumps([p['name'] for p in parameters if p.get('required', False)])}
            }}
        ),'''

        # Generate handler code
        handler_code = f'''
    elif name == "{tool_name}":
        # TODO: Implement {tool_name} logic
        return {{
            "status": "success",
            "message": "Tool {tool_name} executed",
            "arguments": arguments
        }}'''

        # Read current tools file
        with open(tools_path, 'r') as f:
            content = f.read()

        # Insert tool definition
        content = content.replace(
            "    ]\n\n\nasync def handle_tool_call",
            f"{tool_def}\n    ]\n\n\nasync def handle_tool_call"
        )

        # Insert handler
        content = content.replace(
            '    else:\n        return {"error": f"Unknown tool: {name}"}',
            f'{handler_code}\n    else:\n        return {{"error": f"Unknown tool: {{name}}"}}'
        )

        # Write updated content
        with open(tools_path, 'w') as f:
            f.write(content)

        # Update project tools list
        project.tools.append({
            "name": tool_name,
            "description": tool_description,
            "parameters": parameters
        })

        return True

    def _generate_properties(self, parameters: List[Dict[str, Any]]) -> str:
        """Generate JSON schema properties from parameters"""
        props = []
        for param in parameters:
            prop = f'"{param["name"]}": {{\n'
            prop += f'                        "type": "{param.get("type", "string")}",\n'
            prop += f'                        "description": "{param.get("description", "")}"\n'
            if "default" in param:
                prop += f',\n                        "default": {json.dumps(param["default"])}\n'
            prop += '                    }'
            props.append(prop)
        return ',\n                    '.join(props)

    def validate_project(self, project_name: str) -> Dict[str, Any]:
        """Validate a FastMCP project"""
        if project_name not in self.projects:
            raise ValueError(f"Project {project_name} not found")

        project = self.projects[project_name]
        validation_results = {
            "valid": True,
            "errors": [],
            "warnings": [],
            "info": []
        }

        # Check required files
        required_files = ["src/server.py", "src/tools.py", "requirements.txt"]
        for file in required_files:
            if not (project.path / file).exists():
                validation_results["valid"] = False
                validation_results["errors"].append(f"Missing required file: {file}")

        # Check Python syntax
        for py_file in project.path.glob("src/*.py"):
            try:
                with open(py_file, 'r') as f:
                    compile(f.read(), py_file, 'exec')
            except SyntaxError as e:
                validation_results["valid"] = False
                validation_results["errors"].append(f"Syntax error in {py_file}: {e}")

        # Check for common issues
        server_file = project.path / "src" / "server.py"
        if server_file.exists():
            with open(server_file, 'r') as f:
                content = f.read()
                if "asyncio.run(main())" not in content:
                    validation_results["warnings"].append("Missing asyncio.run(main()) in server.py")

        # Info about project
        validation_results["info"].append(f"Project template: {project.template}")
        validation_results["info"].append(f"Tools defined: {len(project.tools)}")

        return validation_results


class FastMCPMCPServer:
    """FastMCP MCP Server implementation"""

    def __init__(self):
        self.server = Server("fastmcp-mcp")
        self.framework = FastMCPFramework()
        self._initialized = False

        # Register handlers
        @self.server.list_tools()
        async def handle_list_tools() -> List[types.Tool]:
            return self._get_tools()

        @self.server.call_tool()
        async def handle_call_tool(name: str, arguments: Optional[Dict[str, Any]] = None) -> List[types.TextContent]:
            return await self._handle_tool_call(name, arguments or {})

    def _get_tools(self) -> List[types.Tool]:
        """Define available FastMCP framework tools"""
        return [
            types.Tool(
                name="fastmcp_create_project",
                description="Create a new FastMCP server project",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "name": {
                            "type": "string",
                            "description": "Project name"
                        },
                        "template": {
                            "type": "string",
                            "description": "Project template to use",
                            "enum": ["basic", "advanced", "enterprise", "ai-agent"],
                            "default": "basic"
                        },
                        "path": {
                            "type": "string",
                            "description": "Base path for project (defaults to current directory)"
                        }
                    },
                    "required": ["name"]
                }
            ),
            types.Tool(
                name="fastmcp_add_tool",
                description="Add a new tool to an existing FastMCP project",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "project_name": {
                            "type": "string",
                            "description": "Name of the project"
                        },
                        "tool_name": {
                            "type": "string",
                            "description": "Name of the new tool"
                        },
                        "tool_description": {
                            "type": "string",
                            "description": "Description of what the tool does"
                        },
                        "parameters": {
                            "type": "array",
                            "description": "Tool parameters",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "name": {"type": "string"},
                                    "type": {"type": "string"},
                                    "description": {"type": "string"},
                                    "required": {"type": "boolean"},
                                    "default": {}
                                }
                            }
                        }
                    },
                    "required": ["project_name", "tool_name", "tool_description"]
                }
            ),
            types.Tool(
                name="fastmcp_list_templates",
                description="List available FastMCP project templates",
                inputSchema={
                    "type": "object",
                    "properties": {}
                }
            ),
            types.Tool(
                name="fastmcp_generate_schema",
                description="Generate JSON schema for a tool",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "tool_name": {
                            "type": "string",
                            "description": "Name of the tool"
                        },
                        "parameters": {
                            "type": "array",
                            "description": "Tool parameters to include in schema"
                        }
                    },
                    "required": ["tool_name", "parameters"]
                }
            ),
            types.Tool(
                name="fastmcp_validate_project",
                description="Validate a FastMCP project structure and syntax",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "project_name": {
                            "type": "string",
                            "description": "Name of the project to validate"
                        }
                    },
                    "required": ["project_name"]
                }
            ),
            types.Tool(
                name="fastmcp_list_projects",
                description="List all created FastMCP projects",
                inputSchema={
                    "type": "object",
                    "properties": {}
                }
            ),
            types.Tool(
                name="fastmcp_deploy_project",
                description="Generate deployment files for a project",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "project_name": {
                            "type": "string",
                            "description": "Name of the project"
                        },
                        "deployment_type": {
                            "type": "string",
                            "description": "Type of deployment",
                            "enum": ["docker", "kubernetes", "systemd"],
                            "default": "docker"
                        }
                    },
                    "required": ["project_name"]
                }
            ),
            types.Tool(
                name="fastmcp_health_check",
                description="Check FastMCP framework health and status",
                inputSchema={
                    "type": "object",
                    "properties": {}
                }
            )
        ]

    async def _handle_tool_call(self, name: str, arguments: Dict[str, Any]) -> List[types.TextContent]:
        """Handle tool execution"""
        try:
            # Route to appropriate handler
            handlers = {
                "fastmcp_create_project": self._create_project,
                "fastmcp_add_tool": self._add_tool,
                "fastmcp_list_templates": self._list_templates,
                "fastmcp_generate_schema": self._generate_schema,
                "fastmcp_validate_project": self._validate_project,
                "fastmcp_list_projects": self._list_projects,
                "fastmcp_deploy_project": self._deploy_project,
                "fastmcp_health_check": self._health_check
            }

            handler = handlers.get(name)
            if not handler:
                result = {"error": f"Unknown tool: {name}"}
            else:
                result = await handler(arguments)

            return [types.TextContent(
                type="text",
                text=json.dumps(result, indent=2)
            )]

        except Exception as e:
            return [types.TextContent(
                type="text",
                text=json.dumps({
                    "error": str(e),
                    "tool": name,
                    "status": "failed"
                }, indent=2)
            )]

    async def _create_project(self, args: Dict[str, Any]) -> Dict[str, Any]:
        """Create a new FastMCP project"""
        name = args["name"]
        template = args.get("template", "basic")
        base_path = Path(args["path"]) if "path" in args else None

        project = self.framework.create_project(name, template, base_path)

        return {
            "status": "success",
            "project": {
                "name": project.name,
                "path": str(project.path),
                "template": project.template,
                "created_at": project.created_at,
                "files_created": len(self.framework.templates[template]["structure"])
            },
            "next_steps": [
                f"cd {project.path}",
                "pip install -r requirements.txt",
                "python src/server.py"
            ]
        }

    async def _add_tool(self, args: Dict[str, Any]) -> Dict[str, Any]:
        """Add a tool to a project"""
        project_name = args["project_name"]
        tool_name = args["tool_name"]
        tool_description = args["tool_description"]
        parameters = args.get("parameters", [])

        success = self.framework.add_tool_to_project(
            project_name, tool_name, tool_description, parameters
        )

        if success:
            return {
                "status": "success",
                "message": f"Tool '{tool_name}' added to project '{project_name}'",
                "tool": {
                    "name": tool_name,
                    "description": tool_description,
                    "parameters": parameters
                }
            }
        else:
            return {
                "status": "failed",
                "error": "Failed to add tool to project"
            }

    async def _list_templates(self, args: Dict[str, Any]) -> Dict[str, Any]:
        """List available templates"""
        templates = []
        for name, template in self.framework.templates.items():
            templates.append({
                "name": name,
                "description": template["description"],
                "files": list(template["structure"].keys())
            })

        return {
            "status": "success",
            "templates": templates,
            "count": len(templates)
        }

    async def _generate_schema(self, args: Dict[str, Any]) -> Dict[str, Any]:
        """Generate tool schema"""
        tool_name = args["tool_name"]
        parameters = args.get("parameters", [])

        schema = {
            "name": tool_name,
            "description": f"Generated schema for {tool_name}",
            "inputSchema": {
                "type": "object",
                "properties": {},
                "required": []
            }
        }

        for param in parameters:
            schema["inputSchema"]["properties"][param["name"]] = {
                "type": param.get("type", "string"),
                "description": param.get("description", "")
            }
            if param.get("default") is not None:
                schema["inputSchema"]["properties"][param["name"]]["default"] = param["default"]
            if param.get("required", False):
                schema["inputSchema"]["required"].append(param["name"])

        return {
            "status": "success",
            "schema": schema
        }

    async def _validate_project(self, args: Dict[str, Any]) -> Dict[str, Any]:
        """Validate a project"""
        project_name = args["project_name"]
        validation_results = self.framework.validate_project(project_name)

        return {
            "status": "success",
            "validation": validation_results,
            "project": project_name
        }

    async def _list_projects(self, args: Dict[str, Any]) -> Dict[str, Any]:
        """List all projects"""
        projects = []
        for name, project in self.framework.projects.items():
            projects.append({
                "name": name,
                "path": str(project.path),
                "template": project.template,
                "created_at": project.created_at,
                "tools_count": len(project.tools)
            })

        return {
            "status": "success",
            "projects": projects,
            "count": len(projects)
        }

    async def _deploy_project(self, args: Dict[str, Any]) -> Dict[str, Any]:
        """Generate deployment files"""
        project_name = args["project_name"]
        deployment_type = args.get("deployment_type", "docker")

        if project_name not in self.framework.projects:
            raise ValueError(f"Project {project_name} not found")

        project = self.framework.projects[project_name]

        if deployment_type == "docker":
            # Generate Dockerfile if not exists
            dockerfile_path = project.path / "Dockerfile"
            if not dockerfile_path.exists():
                with open(dockerfile_path, 'w') as f:
                    f.write(self.framework._get_dockerfile_template())

            # Generate docker-compose.yml if not exists
            compose_path = project.path / "docker-compose.yml"
            if not compose_path.exists():
                with open(compose_path, 'w') as f:
                    f.write(self.framework._get_docker_compose_template())

            return {
                "status": "success",
                "deployment_type": "docker",
                "files_created": ["Dockerfile", "docker-compose.yml"],
                "commands": [
                    "docker build -t {project_name} .",
                    "docker-compose up -d"
                ]
            }

        elif deployment_type == "kubernetes":
            # Generate Kubernetes manifests
            k8s_dir = project.path / "k8s"
            k8s_dir.mkdir(exist_ok=True)

            # Deployment manifest
            deployment_yaml = f"""apiVersion: apps/v1
kind: Deployment
metadata:
  name: {project_name}
spec:
  replicas: 3
  selector:
    matchLabels:
      app: {project_name}
  template:
    metadata:
      labels:
        app: {project_name}
    spec:
      containers:
      - name: {project_name}
        image: {project_name}:latest
        ports:
        - containerPort: 8080
"""
            with open(k8s_dir / "deployment.yaml", 'w') as f:
                f.write(deployment_yaml)

            # Service manifest
            service_yaml = f"""apiVersion: v1
kind: Service
metadata:
  name: {project_name}-service
spec:
  selector:
    app: {project_name}
  ports:
  - port: 80
    targetPort: 8080
  type: LoadBalancer
"""
            with open(k8s_dir / "service.yaml", 'w') as f:
                f.write(service_yaml)

            return {
                "status": "success",
                "deployment_type": "kubernetes",
                "files_created": ["k8s/deployment.yaml", "k8s/service.yaml"],
                "commands": [
                    "kubectl apply -f k8s/"
                ]
            }

        else:
            return {
                "status": "failed",
                "error": f"Unsupported deployment type: {deployment_type}"
            }

    async def _health_check(self) -> Dict[str, Any]:
        """Check framework health"""
        return {
            "status": "healthy",
            "service": "fastmcp-mcp",
            "version": "1.0.0",
            "framework_version": "2.0.0",
            "capabilities": [
                "project_generation",
                "tool_management",
                "schema_generation",
                "deployment_support",
                "template_customization"
            ],
            "templates_available": list(self.framework.templates.keys()),
            "active_projects": len(self.framework.projects),
            "timestamp": datetime.now().isoformat()
        }

    async def run(self):
        """Run the MCP server"""
        async with mcp.server.stdio.stdio_server() as (read_stream, write_stream):
            await self.server.run(
                read_stream,
                write_stream,
                InitializationOptions(
                    server_name="fastmcp-mcp",
                    server_version="1.0.0",
                    capabilities=self.server.get_capabilities(
                        notification_options=NotificationOptions(),
                        experimental_capabilities={},
                    ),
                ),
            )


async def main():
    """Main entry point"""
    server = FastMCPMCPServer()
    await server.run()


if __name__ == "__main__":
    asyncio.run(main())
