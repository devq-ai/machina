#!/usr/bin/env python
"""
FastAPI MCP Server
FastMCP server for FastAPI integration tools and utilities.
Provides FastAPI development, testing, and deployment assistance.
"""
import asyncio
import os
import subprocess
import json
import tempfile
from typing import Any, Dict, List, Optional
from datetime import datetime
from pathlib import Path

import logfire
from fastmcp import FastMCP
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Configure logfire
# logfire.configure(
#     token=os.getenv('LOGFIRE_WRITE_TOKEN'),
#     service_name='fastapi-mcp-server',
#     environment='production'
# )

# Create FastMCP app instance
app = FastMCP("fastapi-mcp")

class FastAPIHelper:
    """FastAPI development and deployment helper."""
    
    def __init__(self):
        self.project_root = os.getenv('PROJECT_ROOT', '/Users/dionedge/devqai/machina')
        self.python_path = os.getenv('PYTHON_PATH', 'python3')
    
    async def run_command(self, cmd: List[str], cwd: Optional[str] = None) -> Dict[str, Any]:
        """Run command and return structured output."""
        try:
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=cwd or self.project_root
            )
            
            stdout, stderr = await process.communicate()
            
            return {
                "command": " ".join(cmd),
                "exit_code": process.returncode,
                "stdout": stdout.decode('utf-8') if stdout else "",
                "stderr": stderr.decode('utf-8') if stderr else "",
                "success": process.returncode == 0
            }
            
        except Exception as e:
            return {
                "command": " ".join(cmd),
                "exit_code": -1,
                "stdout": "",
                "stderr": str(e),
                "success": False,
                "error": str(e)
            }

fastapi_helper = FastAPIHelper()

@app.tool()
@logfire.instrument("fastapi_health_check")
async def fastapi_health_check() -> Dict[str, Any]:
    """Check FastAPI development environment health."""
    # logfire.info("FastAPI health check requested")
    
    try:
        # Check Python and FastAPI availability
        python_check = await fastapi_helper.run_command([fastapi_helper.python_path, '--version'])
        fastapi_check = await fastapi_helper.run_command([
            fastapi_helper.python_path, '-c', 'import fastapi; print(fastapi.__version__)'
        ])
        uvicorn_check = await fastapi_helper.run_command([
            fastapi_helper.python_path, '-c', 'import uvicorn; print(uvicorn.__version__)'
        ])
        
        health_status = {
            "status": "healthy" if all([python_check["success"], fastapi_check["success"], uvicorn_check["success"]]) else "unhealthy",
            "python_version": python_check["stdout"].strip() if python_check["success"] else "not available",
            "fastapi_version": fastapi_check["stdout"].strip() if fastapi_check["success"] else "not installed",
            "uvicorn_version": uvicorn_check["stdout"].strip() if uvicorn_check["success"] else "not installed",
            "project_root": fastapi_helper.project_root,
            "timestamp": datetime.now().isoformat()
        }
        
        # logfire.info("FastAPI health check completed", health_status=health_status)
        return health_status
        
    except Exception as e:
        # logfire.error("FastAPI health check failed", error=str(e))
        pass
        raise

@app.tool()
@logfire.instrument("generate_fastapi_app")
async def generate_fastapi_app(
    app_name: str,
    include_cors: bool = True,
    include_middleware: bool = True,
    include_docs: bool = True
) -> str:
    """Generate a basic FastAPI application template."""
    # logfire.info("Generating FastAPI app", 
    #             app_name=app_name,
    #             include_cors=include_cors,
    #             include_middleware=include_middleware)
    
    try:
        imports = [
            "from fastapi import FastAPI, HTTPException, Depends",
            "from fastapi.responses import JSONResponse",
            "from pydantic import BaseModel",
            "from typing import Optional, List, Dict, Any",
            "from datetime import datetime",
            "import logfire"
        ]
        
        if include_cors:
            imports.append("from fastapi.middleware.cors import CORSMiddleware")
        
        if include_middleware:
            imports.append("from fastapi.middleware.trustedhost import TrustedHostMiddleware")
        
        app_code = f'''#!/usr/bin/env python
"""
{app_name} FastAPI Application
Generated by FastAPI MCP Server
"""
{chr(10).join(imports)}

# Configure logfire
# logfire.configure()

# Create FastAPI app
app = FastAPI(
    title="{app_name}",
    description="FastAPI application generated by MCP server",
    version="1.0.0"
)

# Enable Logfire instrumentation
logfire.instrument_fastapi(app)
'''

        if include_cors:
            app_code += '''
# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
'''

        if include_middleware:
            app_code += '''
# Add security middleware
app.add_middleware(
    TrustedHostMiddleware,
    allowed_hosts=["localhost", "127.0.0.1", "*.example.com"]
)
'''

        app_code += '''
# Pydantic models
class HealthResponse(BaseModel):
    status: str
    timestamp: str
    version: str

class MessageRequest(BaseModel):
    message: str
    priority: Optional[int] = 1

class MessageResponse(BaseModel):
    echo: str
    received_at: str

# Routes
@app.get("/", response_model=Dict[str, str])
async def root():
    """Root endpoint."""
    return {
        "message": f"Welcome to {app_name}",
        "docs": "/docs",
        "health": "/health"
    }

@app.get("/health", response_model=HealthResponse)
async def health_check():
    """Health check endpoint."""
    return HealthResponse(
        status="healthy",
        timestamp=datetime.now().isoformat(),
        version="1.0.0"
    )

@app.post("/echo", response_model=MessageResponse)
async def echo_message(request: MessageRequest):
    """Echo a message back."""
    # logfire.info("Echo request received", message=request.message, priority=request.priority)
    
    return MessageResponse(
        echo=f"Echo: {request.message}",
        received_at=datetime.now().isoformat()
    )

@app.get("/items/{item_id}")
async def get_item(item_id: int, q: Optional[str] = None):
    """Get an item by ID."""
    if item_id < 1:
        raise HTTPException(status_code=400, detail="Item ID must be positive")
    
    return {
        "item_id": item_id,
        "query": q,
        "timestamp": datetime.now().isoformat()
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000, reload=True)
'''

        # logfire.info("FastAPI app generated", 
        #             app_name=app_name,
        #             code_length=len(app_code))
        
        return app_code
        
    except Exception as e:
        # logfire.error("Failed to generate FastAPI app", app_name=app_name, error=str(e))
        pass
        raise

@app.tool()
@logfire.instrument("create_pydantic_model")
async def create_pydantic_model(
    model_name: str,
    fields: Dict[str, str],
    include_validators: bool = False
) -> str:
    """Generate a Pydantic model with specified fields."""
    # logfire.info("Creating Pydantic model", 
    #             model_name=model_name,
    #             field_count=len(fields))
    
    try:
        imports = [
            "from pydantic import BaseModel, Field, validator",
            "from typing import Optional, List, Dict, Any",
            "from datetime import datetime"
        ]
        
        if include_validators:
            imports.append("from pydantic import validator")
        
        model_code = f'''#!/usr/bin/env python
"""
{model_name} Pydantic Model
Generated by FastAPI MCP Server
"""
{chr(10).join(imports)}

class {model_name}(BaseModel):
    """Generated Pydantic model."""
'''

        # Add fields
        for field_name, field_type in fields.items():
            if field_type.startswith("Optional"):
                model_code += f'    {field_name}: {field_type} = None\n'
            else:
                model_code += f'    {field_name}: {field_type}\n'
        
        # Add timestamp field
        model_code += '    created_at: datetime = Field(default_factory=datetime.now)\n'
        
        if include_validators:
            # Add sample validators
            for field_name, field_type in fields.items():
                if 'str' in field_type:
                    model_code += f'''
    @validator('{field_name}')
    def validate_{field_name}(cls, v):
        if v and len(v.strip()) == 0:
            raise ValueError('{field_name} cannot be empty')
        return v
'''
        
        # Add model config
        model_code += '''
    class Config:
        """Pydantic model configuration."""
        validate_assignment = True
        use_enum_values = True
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }
'''

        # logfire.info("Pydantic model created", 
        #             model_name=model_name,
        #             code_length=len(model_code))
        
        return model_code
        
    except Exception as e:
        # logfire.error("Failed to create Pydantic model", 
        pass
        #              model_name=model_name,
        #              error=str(e))
        raise

@app.tool()
@logfire.instrument("generate_openapi_spec")
async def generate_openapi_spec(app_file: str) -> Dict[str, Any]:
    """Generate OpenAPI specification from a FastAPI app."""
    # logfire.info("Generating OpenAPI spec", app_file=app_file)
    
    try:
        # Create a temporary script to extract OpenAPI spec
        temp_script = f'''
import sys
sys.path.insert(0, "{fastapi_helper.project_root}")

try:
    from {app_file.replace('.py', '')} import app
    import json
    
    spec = app.openapi()
    print(json.dumps(spec, indent=2))
except Exception as e:
    print(f"Error: {{e}}", file=sys.stderr)
    sys.exit(1)
'''
        
        with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
            f.write(temp_script)
            temp_script_path = f.name
        
        try:
            result = await fastapi_helper.run_command([
                fastapi_helper.python_path, temp_script_path
            ])
            
            if result["success"]:
                openapi_spec = json.loads(result["stdout"])
                
                # logfire.info("OpenAPI spec generated successfully", 
                #             app_file=app_file,
                #             spec_size=len(str(openapi_spec)))
                
                return openapi_spec
            else:
                raise RuntimeError(f"Failed to generate OpenAPI spec: {result['stderr']}")
                
        finally:
            os.unlink(temp_script_path)
            
    except Exception as e:
        # logfire.error("Failed to generate OpenAPI spec", app_file=app_file, error=str(e))
        pass
        raise

@app.tool()
@logfire.instrument("run_fastapi_server")
async def run_fastapi_server(
    app_file: str,
    host: str = "127.0.0.1",
    port: int = 8000,
    reload: bool = True
) -> Dict[str, Any]:
    """Start a FastAPI development server."""
    # logfire.info("Starting FastAPI server", 
    #             app_file=app_file,
    #             host=host,
    #             port=port,
    #             reload=reload)
    
    try:
        # Build uvicorn command
        cmd = [
            fastapi_helper.python_path, '-m', 'uvicorn',
            f'{app_file.replace(".py", "")}:app',
            '--host', host,
            '--port', str(port)
        ]
        
        if reload:
            cmd.append('--reload')
        
        # Start server (non-blocking)
        result = await fastapi_helper.run_command(cmd)
        
        server_info = {
            "status": "started" if result["success"] else "failed",
            "app_file": app_file,
            "host": host,
            "port": port,
            "reload": reload,
            "url": f"http://{host}:{port}",
            "docs_url": f"http://{host}:{port}/docs",
            "command": result["command"],
            "timestamp": datetime.now().isoformat()
        }
        
        if not result["success"]:
            server_info["error"] = result["stderr"]
        
        # logfire.info("FastAPI server start attempted", 
        #             app_file=app_file,
        #             status=server_info["status"],
        #             url=server_info["url"])
        
        return server_info
        
    except Exception as e:
        # logfire.error("Failed to start FastAPI server", 
        pass
        #              app_file=app_file,
        #              error=str(e))
        raise

@app.tool()
@logfire.instrument("validate_fastapi_app")
async def validate_fastapi_app(app_file: str) -> Dict[str, Any]:
    """Validate a FastAPI application for common issues."""
    # logfire.info("Validating FastAPI app", app_file=app_file)
    
    try:
        app_path = Path(fastapi_helper.project_root) / app_file
        
        if not app_path.exists():
            raise FileNotFoundError(f"FastAPI app file not found: {app_file}")
        
        # Read and analyze the app file
        with open(app_path, 'r') as f:
            content = f.read()
        
        issues = []
        warnings = []
        
        # Check for required imports
        required_imports = ['FastAPI', 'logfire']
        for imp in required_imports:
            if imp not in content:
                issues.append(f"Missing import: {imp}")
        
        # Check for app instance
        if 'app = FastAPI(' not in content:
            issues.append("No FastAPI app instance found")
        
        # Check for logfire instrumentation
        if 'logfire.instrument_fastapi' not in content:
            warnings.append("Missing logfire instrumentation")
        
        # Check for health endpoint
        if '/health' not in content:
            warnings.append("No health check endpoint found")
        
        # Check for CORS if needed
        if 'CORSMiddleware' not in content:
            warnings.append("Consider adding CORS middleware for frontend integration")
        
        # Try to validate syntax
        try:
            compile(content, app_file, 'exec')
        except SyntaxError as e:
            issues.append(f"Syntax error: {e}")
        
        validation_result = {
            "status": "valid" if len(issues) == 0 else "invalid",
            "app_file": app_file,
            "issues_count": len(issues),
            "warnings_count": len(warnings),
            "issues": issues,
            "warnings": warnings,
            "timestamp": datetime.now().isoformat()
        }
        
        # logfire.info("FastAPI app validation completed", 
        #             app_file=app_file,
        #             status=validation_result["status"],
        #             issues_count=len(issues),
        #             warnings_count=len(warnings))
        
        return validation_result
        
    except Exception as e:
        # logfire.error("FastAPI app validation failed", app_file=app_file, error=str(e))
        pass
        raise

# Server startup handler

async def startup():
    """Server startup handler."""
    # logfire.info("FastAPI MCP server starting up")
    
    # Test FastAPI environment on startup
    try:
        await fastapi_health_check()
        # logfire.info("FastAPI environment verified on startup")
    except Exception as e:
        # logfire.warning("FastAPI environment test failed on startup", error=str(e))


        pass
async def shutdown():
    """Server shutdown handler."""
    # logfire.info("FastAPI MCP server shutting down")

if __name__ == "__main__":
    # logfire.info("Starting FastAPI MCP server")
    import asyncio
    asyncio.run(app.run_stdio_async())