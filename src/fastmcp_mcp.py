#!/usr/bin/env python
"""
FastMCP MCP Server
FastMCP server for FastMCP framework utilities and development tools.
Provides FastMCP project generation, testing, and management capabilities.
"""
import asyncio
import os
import subprocess
import json
import tempfile
from typing import Any, Dict, List, Optional
from datetime import datetime
from pathlib import Path

import logfire
from fastmcp import FastMCP
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Configure logfire
# logfire.configure(
#     token=os.getenv('LOGFIRE_WRITE_TOKEN'),
#     service_name='fastmcp-mcp-server',
#     environment='production'
# )

# Create FastMCP app instance
app = FastMCP("fastmcp-mcp")

class FastMCPHelper:
    """FastMCP framework development helper."""
    
    def __init__(self):
        self.project_root = os.getenv('PROJECT_ROOT', '/Users/dionedge/devqai/machina')
        self.python_path = os.getenv('PYTHON_PATH', 'python3')
    
    async def run_command(self, cmd: List[str], cwd: Optional[str] = None) -> Dict[str, Any]:
        """Run command and return structured output."""
        try:
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=cwd or self.project_root
            )
            
            stdout, stderr = await process.communicate()
            
            return {
                "command": " ".join(cmd),
                "exit_code": process.returncode,
                "stdout": stdout.decode('utf-8') if stdout else "",
                "stderr": stderr.decode('utf-8') if stderr else "",
                "success": process.returncode == 0
            }
            
        except Exception as e:
            return {
                "command": " ".join(cmd),
                "exit_code": -1,
                "stdout": "",
                "stderr": str(e),
                "success": False,
                "error": str(e)
            }

fastmcp_helper = FastMCPHelper()

@app.tool()
@logfire.instrument("fastmcp_health_check")
async def fastmcp_health_check() -> Dict[str, Any]:
    """Check FastMCP framework health and installation."""
    # logfire.info("FastMCP health check requested")
    
    try:
        # Check Python and FastMCP availability
        python_check = await fastmcp_helper.run_command([fastmcp_helper.python_path, '--version'])
        fastmcp_check = await fastmcp_helper.run_command([
            fastmcp_helper.python_path, '-c', 'import fastmcp; print(fastmcp.__version__)'
        ])
        mcp_check = await fastmcp_helper.run_command([
            fastmcp_helper.python_path, '-c', 'import mcp; print(mcp.__version__)'
        ])
        
        health_status = {
            "status": "healthy" if all([python_check["success"], fastmcp_check["success"], mcp_check["success"]]) else "unhealthy",
            "python_version": python_check["stdout"].strip() if python_check["success"] else "not available",
            "fastmcp_version": fastmcp_check["stdout"].strip() if fastmcp_check["success"] else "not installed",
            "mcp_version": mcp_check["stdout"].strip() if mcp_check["success"] else "not installed",
            "project_root": fastmcp_helper.project_root,
            "timestamp": datetime.now().isoformat()
        }
        
        # logfire.info("FastMCP health check completed", health_status=health_status)
        return health_status
        
    except Exception as e:
        # logfire.error("FastMCP health check failed", error=str(e))
        pass
        raise

@app.tool()
@logfire.instrument("generate_fastmcp_server")
async def generate_fastmcp_server(
    server_name: str,
    tools: List[str],
    include_logfire: bool = True,
    include_startup_handlers: bool = True
) -> str:
    """Generate a FastMCP server template with specified tools."""
    # logfire.info("Generating FastMCP server", 
    #             server_name=server_name,
    #             tool_count=len(tools),
    #             include_logfire=include_logfire)
    
    try:
        imports = [
            "import asyncio",
            "import os",
            "from typing import Any, Dict, List, Optional",
            "from datetime import datetime",
            "",
            "from fastmcp import FastMCP",
            "from dotenv import load_dotenv"
        ]
        
        if include_logfire:
            imports.insert(-1, "import logfire")
        
        server_code = f'''#!/usr/bin/env python
"""
{server_name} FastMCP Server
Generated by FastMCP MCP Server
"""
{chr(10).join(imports)}

# Load environment variables
load_dotenv()
'''

        if include_logfire:
            server_code += f'''
# Configure logfire
# logfire.configure(
#     token=os.getenv('LOGFIRE_WRITE_TOKEN'),
#     service_name='{server_name.lower().replace('_', '-')}-server',
#     environment='production'
# )
'''

        server_code += f'''
# Create FastMCP app instance
app = FastMCP("{server_name}")
'''

        # Generate tools
        for tool_name in tools:
            if include_logfire:
                server_code += f'''
@app.tool()
@logfire.instrument("{tool_name}")
async def {tool_name}(message: str = "Hello World") -> str:
    """Generated tool: {tool_name}."""
    # logfire.info("{tool_name} called", message=message)
    
    try:
        # TODO: Implement {tool_name} logic here
        result = f"{tool_name} processed: {{message}}"
        
        # logfire.info("{tool_name} completed", message=message, result_length=len(result))
        return result
        
    except Exception as e:
        # logfire.error("{tool_name} failed", message=message, error=str(e))
        pass
        raise
'''
            else:
                server_code += f'''
@app.tool()
async def {tool_name}(message: str = "Hello World") -> str:
    """Generated tool: {tool_name}."""
    # TODO: Implement {tool_name} logic here
    return f"{tool_name} processed: {{message}}"
'''

        if include_startup_handlers:
            if include_logfire:
                server_code += f'''
# Server startup and shutdown handlers

async def startup():
    """Server startup handler."""
    # logfire.info("{server_name} server starting up")


async def shutdown():
    """Server shutdown handler."""
    # logfire.info("{server_name} server shutting down")
'''
            else:
                server_code += f'''
# Server startup and shutdown handlers

async def startup():
    """Server startup handler."""
    print("{server_name} server starting up")


async def shutdown():
    """Server shutdown handler."""
    print("{server_name} server shutting down")
'''

        server_code += f'''
if __name__ == "__main__":
'''
        if include_logfire:
            server_code += f'    # logfire.info("Starting {server_name} server")\n'
        
        server_code += '''    import asyncio
    asyncio.run(app.run_stdio_async())'''
        
        # logfire.info("FastMCP server generated", 
        #             server_name=server_name,
        #             code_length=len(server_code),
        #             tool_count=len(tools))
        
        return server_code
        
    except Exception as e:
        # logfire.error("Failed to generate FastMCP server", 
        pass
        #              server_name=server_name,
        #              error=str(e))
        raise

@app.tool()
@logfire.instrument("test_fastmcp_server")
async def test_fastmcp_server(server_file: str) -> Dict[str, Any]:
    """Test a FastMCP server by importing and analyzing its tools."""
    # logfire.info("Testing FastMCP server", server_file=server_file)
    
    try:
        # Create a temporary test script
        test_script = f'''
import sys
sys.path.insert(0, "{fastmcp_helper.project_root}/src")

try:
    from {server_file.replace('.py', '')} import app
    
    # Get tools information
    tools = []
    if hasattr(app, '_tools'):
        for tool_name, tool_func in app._tools.items():
            tools.append({{
                "name": tool_name,
                "description": getattr(tool_func, '__doc__', 'No description'),
                "signature": str(tool_func.__annotations__) if hasattr(tool_func, '__annotations__') else "No annotations"
            }})
    
    result = {{
        "server_name": app.name if hasattr(app, 'name') else 'unknown',
        "tool_count": len(tools),
        "tools": tools,
        "status": "success"
    }}
    
    import json
    print(json.dumps(result, indent=2))
    
except Exception as e:
    error_result = {{
        "status": "error",
        "error": str(e),
        "tool_count": 0,
        "tools": []
    }}
    import json
    print(json.dumps(error_result, indent=2))
'''
        
        with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
            f.write(test_script)
            temp_script_path = f.name
        
        try:
            result = await fastmcp_helper.run_command([
                fastmcp_helper.python_path, temp_script_path
            ])
            
            if result["success"]:
                test_result = json.loads(result["stdout"])
                test_result["timestamp"] = datetime.now().isoformat()
                test_result["server_file"] = server_file
                
                # logfire.info("FastMCP server test completed", 
                #             server_file=server_file,
                #             status=test_result["status"],
                #             tool_count=test_result["tool_count"])
                
                return test_result
            else:
                raise RuntimeError(f"Failed to test server: {result['stderr']}")
                
        finally:
            os.unlink(temp_script_path)
            
    except Exception as e:
        # logfire.error("Failed to test FastMCP server", server_file=server_file, error=str(e))
        pass
        raise

@app.tool()
@logfire.instrument("create_fastmcp_tool")
async def create_fastmcp_tool(
    tool_name: str,
    parameters: Dict[str, str],
    return_type: str = "str",
    include_logfire: bool = True,
    include_error_handling: bool = True
) -> str:
    """Generate a FastMCP tool function."""
    # logfire.info("Creating FastMCP tool", 
    #             tool_name=tool_name,
    #             param_count=len(parameters))
    
    try:
        # Build parameter signature
        param_list = []
        for param_name, param_type in parameters.items():
            if param_type.startswith("Optional"):
                param_list.append(f"{param_name}: {param_type} = None")
            else:
                param_list.append(f"{param_name}: {param_type}")
        
        param_signature = ", ".join(param_list)
        
        # Generate tool code
        tool_code = f'''@app.tool()'''
        
        if include_logfire:
            tool_code += f'''
@logfire.instrument("{tool_name}")'''
        
        tool_code += f'''
async def {tool_name}({param_signature}) -> {return_type}:
    """Generated FastMCP tool: {tool_name}."""'''
        
        if include_logfire:
            log_params = ", ".join([f"{p}={p}" for p in parameters.keys()])
            tool_code += f'''
    # logfire.info("{tool_name} called", {log_params})'''
        
        if include_error_handling:
            tool_code += f'''
    
    try:
        # TODO: Implement {tool_name} logic here'''
            
            # Add basic implementation based on return type
            if return_type == "str":
                tool_code += f'''
        result = f"Processed {tool_name} with parameters: {{{', '.join([f'{p}={{{p}}}' for p in parameters.keys()])}}}"'''
            elif return_type == "Dict[str, Any]":
                tool_code += f'''
        result = {{
            "tool": "{tool_name}",
            "timestamp": datetime.now().isoformat(),'''
                for param in parameters.keys():
                    tool_code += f'''
            "{param}": {param},'''
                tool_code += '''
            "status": "success"
        }'''
            elif return_type == "List[str]":
                tool_code += f'''
        result = [f"Result from {tool_name}", "Additional data"]'''
            else:
                tool_code += f'''
        result = "Default result from {tool_name}"'''
            
            if include_logfire:
                tool_code += f'''
        
        # logfire.info("{tool_name} completed", result=str(result))'''
                
            tool_code += f'''
        return result
        
    except Exception as e:'''
            
            if include_logfire:
                tool_code += f'''
        # logfire.error("{tool_name} failed", {log_params}, error=str(e))'''
            
            tool_code += '''
        raise'''
        else:
            # Simple implementation without error handling
            if return_type == "str":
                tool_code += f'''
    return f"Processed {tool_name} with parameters: {{{', '.join([f'{p}={{{p}}}' for p in parameters.keys()])}}}"'''
            else:
                tool_code += f'''
    # TODO: Implement {tool_name} logic here
    return "Default result"'''
        
        # logfire.info("FastMCP tool created", 
        #             tool_name=tool_name,
        #             code_length=len(tool_code))
        
        return tool_code
        
    except Exception as e:
        # logfire.error("Failed to create FastMCP tool", 
        pass
        #              tool_name=tool_name,
        #              error=str(e))
        raise

@app.tool()
@logfire.instrument("validate_fastmcp_server")
async def validate_fastmcp_server(server_file: str) -> Dict[str, Any]:
    """Validate a FastMCP server for common issues and best practices."""
    # logfire.info("Validating FastMCP server", server_file=server_file)
    
    try:
        server_path = Path(fastmcp_helper.project_root) / "src" / server_file
        
        if not server_path.exists():
            raise FileNotFoundError(f"FastMCP server file not found: {server_file}")
        
        # Read and analyze the server file
        with open(server_path, 'r') as f:
            content = f.read()
        
        issues = []
        warnings = []
        suggestions = []
        
        # Check for required imports
        required_imports = ['FastMCP', 'logfire']
        for imp in required_imports:
            if imp not in content:
                if imp == 'logfire':
                    warnings.append("Missing logfire import - observability recommended")
                else:
                    issues.append(f"Missing required import: {imp}")
        
        # Check for app instance
        if 'app = FastMCP(' not in content:
            issues.append("No FastMCP app instance found")
        
        # Check for tool definitions
        tool_count = content.count('@app.tool()')
        if tool_count == 0:
            warnings.append("No tools defined in server")
        
        # Check for logfire instrumentation
        if '@logfire.instrument(' not in content and 'logfire' in content:
            suggestions.append("Consider adding logfire instrumentation to tools")
        
        # Check for startup/shutdown handlers
        if '' not in content:
            suggestions.append("Consider adding startup handler")
        if '' not in content:
            suggestions.append("Consider adding shutdown handler")
        
        # Check for error handling
        if 'try:' not in content or 'except' not in content:
            warnings.append("No error handling found - consider adding try/except blocks")
        
        # Check for type hints
        if 'async def' in content and '->' not in content:
            suggestions.append("Consider adding return type hints to functions")
        
        # Try to validate syntax
        try:
            compile(content, server_file, 'exec')
        except SyntaxError as e:
            issues.append(f"Syntax error: {e}")
        
        validation_result = {
            "status": "valid" if len(issues) == 0 else "invalid",
            "server_file": server_file,
            "tool_count": tool_count,
            "issues_count": len(issues),
            "warnings_count": len(warnings),
            "suggestions_count": len(suggestions),
            "issues": issues,
            "warnings": warnings,
            "suggestions": suggestions,
            "timestamp": datetime.now().isoformat()
        }
        
        # logfire.info("FastMCP server validation completed", 
        #             server_file=server_file,
        #             status=validation_result["status"],
        #             tool_count=tool_count,
        #             issues_count=len(issues))
        
        return validation_result
        
    except Exception as e:
        # logfire.error("FastMCP server validation failed", 
        pass
        #              server_file=server_file,
        #              error=str(e))
        raise

@app.tool()
@logfire.instrument("list_fastmcp_servers")
async def list_fastmcp_servers() -> List[Dict[str, Any]]:
    """List all FastMCP servers in the src directory."""
    # logfire.info("Listing FastMCP servers")
    
    try:
        src_dir = Path(fastmcp_helper.project_root) / "src"
        servers = []
        
        for py_file in src_dir.glob("*.py"):
            try:
                with open(py_file, 'r') as f:
                    content = f.read()
                
                if 'FastMCP' in content and 'app = FastMCP(' in content:
                    # Extract server info
                    tool_count = content.count('@app.tool()')
                    has_logfire = 'logfire' in content
                    has_error_handling = 'try:' in content and 'except' in content
                    
                    servers.append({
                        "filename": py_file.name,
                        "tool_count": tool_count,
                        "has_logfire": has_logfire,
                        "has_error_handling": has_error_handling,
                        "file_size": py_file.stat().st_size,
                        "last_modified": datetime.fromtimestamp(
                            py_file.stat().st_mtime
                        ).isoformat()
                    })
            except Exception as e:
                # logfire.warning("Error analyzing file", 
                pass
                #                filename=py_file.name,
                #                error=str(e))
        
        # logfire.info("FastMCP servers listed", count=len(servers))
        return servers
        
    except Exception as e:
        # logfire.error("Failed to list FastMCP servers", error=str(e))
        pass
        raise

# Server startup handler

async def startup():
    """Server startup handler."""
    # logfire.info("FastMCP MCP server starting up")
    
    # Test FastMCP environment on startup
    try:
        await fastmcp_health_check()
        # logfire.info("FastMCP environment verified on startup")
    except Exception as e:
        # logfire.warning("FastMCP environment test failed on startup", error=str(e))


        pass
async def shutdown():
    """Server shutdown handler."""
    # logfire.info("FastMCP MCP server shutting down")

if __name__ == "__main__":
    # logfire.info("Starting FastMCP MCP server")
    import asyncio
    asyncio.run(app.run_stdio_async())